<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>N-puzzle Problem | Wood</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="​     N-Puzzle Problem[TOC] PreviewN-Puzzle Problem:在人工智能中，常常以N-Puzzle 问题的求解为例子来说明各种搜索策略。 N=K*K-1; 当N=8时，即为重排九宫格问题；当N=15时，即为十五迷问题； 一个状态：N个数码及一个空格的每一组置放形式，就形成了该问题的一个状态。 N-Puzzle问题空间：所有（N+1)!个互不相同的状态构成了">
<meta name="keywords" content="AI,N-Puzzle,搜索">
<meta property="og:type" content="article">
<meta property="og:title" content="N-puzzle Problem">
<meta property="og:url" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/index.html">
<meta property="og:site_name" content="Wood">
<meta property="og:description" content="​     N-Puzzle Problem[TOC] PreviewN-Puzzle Problem:在人工智能中，常常以N-Puzzle 问题的求解为例子来说明各种搜索策略。 N=K*K-1; 当N=8时，即为重排九宫格问题；当N=15时，即为十五迷问题； 一个状态：N个数码及一个空格的每一组置放形式，就形成了该问题的一个状态。 N-Puzzle问题空间：所有（N+1)!个互不相同的状态构成了">
<meta property="og:locale" content="中文&English">
<meta property="og:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/10.png">
<meta property="og:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/2.png">
<meta property="og:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/9.png">
<meta property="og:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/4.png">
<meta property="og:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/5.png">
<meta property="og:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/3.png">
<meta property="og:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/6.png">
<meta property="og:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/7.png">
<meta property="og:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/8.png">
<meta property="og:updated_time" content="2019-05-15T08:16:07.856Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="N-puzzle Problem">
<meta name="twitter:description" content="​     N-Puzzle Problem[TOC] PreviewN-Puzzle Problem:在人工智能中，常常以N-Puzzle 问题的求解为例子来说明各种搜索策略。 N=K*K-1; 当N=8时，即为重排九宫格问题；当N=15时，即为十五迷问题； 一个状态：N个数码及一个空格的每一组置放形式，就形成了该问题的一个状态。 N-Puzzle问题空间：所有（N+1)!个互不相同的状态构成了">
<meta name="twitter:image" content="http://yoursite.com/2019/04/23/N-puzzle-Problem/10.png">
  
    <link rel="alternate" href="/atom.xml" title="Wood" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Wood</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">ACMer;loser;逐梦失败者；只有经历了一些事，您才会懂得好好珍惜眼前的时光！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-N-puzzle-Problem" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/23/N-puzzle-Problem/" class="article-date">
  <time datetime="2019-04-23T15:41:26.000Z" itemprop="datePublished">2019-04-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      N-puzzle Problem
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​    </p>
<h1 id="N-Puzzle-Problem"><a href="#N-Puzzle-Problem" class="headerlink" title="N-Puzzle Problem"></a>N-Puzzle Problem</h1><p>[TOC]</p>
<h2 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h2><h3 id="N-Puzzle-Problem-1"><a href="#N-Puzzle-Problem-1" class="headerlink" title="N-Puzzle Problem:"></a>N-Puzzle Problem:</h3><p>在人工智能中，常常以N-Puzzle 问题的求解为例子来说明各种搜索策略。</p>
<p>N=K*K-1;</p>
<p>当N=8时，即为重排九宫格问题；当N=15时，即为十五迷问题；</p>
<p>一个状态：N个数码及一个空格的每一组置放形式，就形成了该问题的一个状态。</p>
<p>N-Puzzle问题空间：所有（N+1)!个互不相同的状态构成了一个N-Puzzle问题空间。</p>
<p>128M 1e7</p>
<p><strong>操作</strong>：平移操作——把与空格相邻 的某一数码移入空格，称这种操作为平移操作。</p>
<p><strong>Problem:</strong>对于给定的任一初始状态，使用平移操作，求解到目标状态的最优步数 (最少步骤的移法) 以及移动的每一步状态。</p>
<p><strong>Goal position:</strong></p>
<p><img src="/2019/04/23/N-puzzle-Problem/10.png" alt="1556368035445"></p>
<h3 id="N-Puzzle-Problem-的可解性判断"><a href="#N-Puzzle-Problem-的可解性判断" class="headerlink" title="N-Puzzle Problem 的可解性判断"></a>N-Puzzle Problem 的可解性判断</h3><p>分奇偶性然后根据逆序数判断。</p>
<p><a href="https://blog.csdn.net/Wood_Du/article/details/88730885" target="_blank" rel="noopener">https://blog.csdn.net/Wood_Du/article/details/88730885</a></p>
<h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><p>​        N-Puzzle问题之所以能用来为例说明各种搜索策略，在于对于N-Puzzle问题，根据所需求解的初始状态的复杂性，我们可以从爆搜开始，一步一步优化，当某种算法不足于求解时，可从优化数据结构，更换搜索算法上升一个境界，求得更加复杂的初始状态的解。</p>
<p>：你会搜索吗？</p>
<p>：我会爆搜 dfs+STL库，但是DFS不能找到最优解；找最优解我会bfs</p>
<p>：那么存状态呢？</p>
<p>：STL库会很废效率，我可以用hash判重；正好学了Zobrist Hash</p>
<p>：你还有什么可以进一步优化吗？</p>
<p>：为了减少状态的膨胀，我可以使用双向广搜，从初始状态和目标状态同时开始搜索，当某方向遇到另一个方向搜索过的状态的时候，则搜索成功。两个方向对接得到最后结果。</p>
<p>：这些都是无信息搜索算法，你可以使用有信息搜索吗？</p>
<p>：启发式搜索，那就想办法减少搜索范围，降低问题复杂度。这个时候我们就可以上A*+Hash了。启发函数可以用错位数或者曼哈顿距离。</p>
<p>：对于A*，需要每次找到Open表中f（f(n) = g(n)+h(n))  最小的的元素。如果排序那么工作量会很大应该怎么办呢？</p>
<p>：上优先队列</p>
<p>：但是对于15码问题，内存不能存下状态了</p>
<p>:  IDA*,解决内存问题。</p>
<p>是基于迭代加深的A*算法。并且不需要判重，不需要估价排序，用不到哈希表，空间需求量变得超级少。启发函数用曼哈顿距离。在找最优解的时候，对超过目前最优解的地方进行剪枝，可导致搜索深度急剧减少。再check一下不要回到上个状态。</p>
<p>：一般的15码样例都能解决，但是对于15码最复杂的一些样例，仍然需要三四十分钟才能解出答案。还有什么可以优化吗？</p>
<p>：那就只能去啃英文论文了。A.Felner,R.Korf的Disjoint Pattern Database Heuristics,      不相交模式数据库启发式算法。Additive Pattern Database Heuristics  ——E.Korf，A.Felner，S.Hanan。这是一中新的设计更精确的可容许启发式评价函数的方法，该方法基于模式数据库。</p>
<p>本文我们将略去无信息搜索算法，求解最小步数，详解算法为：</p>
<p>从A* 开始，优化数据结构；</p>
<p>再到IDA*；</p>
<p>最后用Pattern Database Heuristics解决15码最复杂的样例。</p>
<p>针对不同复杂度的样例，本文后面将分为三个阶段。</p>
<p>每个阶段将说明解决的样例，求解的要求时间，算法以及启发函数，代码实现以及每个样例的解决时间。</p>
<p>对于展示代码因为代码量很大，并且是一个框架，所以只能展示核心代码，若需要查看整个项目代码，我会push到github上。</p>
<h2 id="Three-Stages-and-Related-Algorithms"><a href="#Three-Stages-and-Related-Algorithms" class="headerlink" title="Three Stages and Related Algorithms"></a>Three Stages and Related Algorithms</h2><h3 id="First-phase："><a href="#First-phase：" class="headerlink" title="First phase："></a>First phase：</h3><h4 id="所需解决样例以及最多时间："><a href="#所需解决样例以及最多时间：" class="headerlink" title="所需解决样例以及最多时间："></a>所需解决样例以及最多时间：</h4><p>​            <strong>对于以下两个实例，均能够在1秒之类解出</strong></p>
<p><img src="/2019/04/23/N-puzzle-Problem/2.png" alt="1556377705625"></p>
<h4 id="Algorithm：A"><a href="#Algorithm：A" class="headerlink" title="Algorithm：A*"></a>Algorithm：A*</h4><p>​    A*算法是一种静态网中求解最短路径最有效的直接搜索方法也是也是一种启发式算法。在搜索过程中使用启发函数。估价函数与实际值越接近，最终搜索到目标格局的时间越快。</p>
<p>估价函数表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f(n) = g(n) + h(n)</span><br><span class="line"><span class="comment">//f(n) 表示从初始状态到目标状态的估测代价</span></span><br><span class="line"><span class="comment">//g(n) 表示从初始状态到当前状态（节点n）的代价（已经确定）</span></span><br><span class="line"><span class="comment">//h(n) 表示从当前状态(节点n)到目标状态的估测代价(预测)</span></span><br><span class="line">    </span><br><span class="line">h(n) &lt; h'(n) <span class="comment">//h'(n)为当前状态到目标状态的实际步数</span></span><br></pre></td></tr></table></figure>
<p>h(n)  的好坏直接影响评估函数的好坏。</p>
<p>流程图：</p>
<p>//N-puzzle-Problem\</p>
<p><img src="/2019/04/23/N-puzzle-Problem/9.png" alt="1556381217714"></p>
<p>​    从初始状态出发  =&gt;经过一系列中间状态 =&gt;最终到达目标状态（或者无法到达）。</p>
<p>​      该算法用于经过中间状态时候的行进策略（其中的中间状态或者由题目给出，或者在前边已经推导得出）。</p>
<p>优点：与广度优先搜索策略和深度优先搜索策略相比，A*算法不是盲目搜索，而是有提示的搜索</p>
<p>缺点：该算法一般要使用大量的空间用于存储已搜索过的中间状态，防止重复搜索。随着样例变复杂将会爆内存。</p>
<h4 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h4><p>完整代码传送门：？？？</p>
<p>Search为A*算法，此代码由于调用了框架中其他类的代码所以比较抽象，我是边百度java边写这个项目，没学过java的娃娃面向百度编程。所以如果你会java,相信你吨吨吨就看明白我代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> core.astar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> core.problem.Action;</span><br><span class="line"><span class="keyword">import</span> core.problem.Problem; <span class="comment">//操作</span></span><br><span class="line"><span class="keyword">import</span> core.problem.State;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AStar</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AStar</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.problem = problem;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">childNode</span><span class="params">(Node parent, Action action)</span> </span>&#123;</span><br><span class="line">		State state = problem.result(parent.getState(), action);</span><br><span class="line">		<span class="comment">//getPathCost 初始到当前的实际代价   stepCost 从父级到后续任务的路径成本</span></span><br><span class="line">		<span class="keyword">int</span> pathCost = parent.getPathCost() + problem.stepCost(parent.getState(), action);</span><br><span class="line">		<span class="keyword">int</span> heuristic = problem.heuristic(state);  <span class="comment">//估计从状态到目标状态最便宜路径的成本</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Node(state, parent, action, pathCost, heuristic);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Problem <span class="title">getProblem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> problem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProblem</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.problem = problem;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">Search</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//起始节点</span></span><br><span class="line">		State initState = problem.getInitialState();</span><br><span class="line">		Node node = <span class="keyword">new</span> Node(initState, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, problem.heuristic(initState));</span><br><span class="line">		</span><br><span class="line">		Fringe fringe = <span class="keyword">new</span> Fringe();</span><br><span class="line">		fringe.insert(node);</span><br><span class="line">		</span><br><span class="line">		Explored explored = <span class="keyword">new</span> Explored();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (fringe.isEmpty())	<span class="keyword">return</span> <span class="keyword">null</span>;	<span class="comment">//失败</span></span><br><span class="line">			</span><br><span class="line">			node = fringe.pop(); <span class="comment">//choose the lowest-cost node in frontier</span></span><br><span class="line">			<span class="keyword">if</span> (problem.goalTest(node.getState())) <span class="keyword">return</span> node;</span><br><span class="line">			explored.insert(node.getState());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (Action action : problem.Actions(node.getState())) &#123;</span><br><span class="line">				Node child = childNode(node, action);</span><br><span class="line">				<span class="comment">//child.getState()不再在扩展节点的集合(Close表中）且fringe(Open表）中不存在状态为state的节点  则将节点插入fringe中</span></span><br><span class="line">				<span class="keyword">if</span> (!explored.contains(child.getState()) &amp;&amp; !fringe.contains(child.getState())) &#123;</span><br><span class="line">					fringe.insert(child);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/**</span></span><br><span class="line"><span class="comment">					如果邻接结点N’在CLOSED表中，比较CLOSED表中的g(N')值和当前的g(N')值，如果当前的g(N')更小，那么删除CLOSED表中的N'，把N设成N'的父节点，重新将N'插入OPEN表。</span></span><br><span class="line"><span class="comment">   	如果邻接结点N’在OPEN表中，比较OPEN表中的g(N')值和当前的g(N')值，如果当前的g(N')更小，那么删除OPEN表中的N'，把N设成N'的父节点，重新将N'插入OPEN表。</span></span><br><span class="line"><span class="comment">				***/</span></span><br><span class="line">					Node revisited = fringe.revisited(child.getState());</span><br><span class="line">					<span class="keyword">if</span> (revisited != <span class="keyword">null</span> &amp;&amp; revisited.evaluation() &gt; child.evaluation()) &#123;</span><br><span class="line">						fringe.replace(revisited, child);<span class="comment">//用child节点代替Fringe中的 revisited节点</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//用动画展示问题的解路径</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// Fix me</span></span><br><span class="line">		<span class="comment">// 调用Problem的drawWorld方法，和simulateResult方法</span></span><br><span class="line">		problem.drawWorld();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Problem problem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Result"><a href="#Result" class="headerlink" title="Result:"></a>Result:</h4><p>项目目录：Searching_Student: E:\University\AI\Searching_student</p>
<table>
<thead>
<tr>
<th>No</th>
<th>Initial State</th>
<th>Steps</th>
<th>Time</th>
<th>Limited Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8, 6, 7, 2, 5, 4, 3, 0, 1</td>
<td>31</td>
<td>0.132s</td>
<td>1s</td>
</tr>
<tr>
<td>2</td>
<td>6, 4, 7, 8, 5, 0, 3, 2, 1</td>
<td>31</td>
<td>0.133s</td>
<td>1s</td>
</tr>
<tr>
<td>3</td>
<td>8, 13, 0, 6, 1, 15, 9, 14, 3, 4, 5, 11, 7, 2, 10, 12</td>
<td>52</td>
<td>1.929s</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>2,9,5,11, 8,3,4,14, 7,10,1,12,  0,15,6,13</td>
<td>GC</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>4,7,0,9,12,10,11,8,14,6,15,1,2,5,3,13</td>
<td>GC</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="Second-phase："><a href="#Second-phase：" class="headerlink" title="Second phase："></a>Second phase：</h3><h4 id="所需解决样例以及最多时间：-1"><a href="#所需解决样例以及最多时间：-1" class="headerlink" title="所需解决样例以及最多时间："></a>所需解决样例以及最多时间：</h4><p><strong>4阶的，能够在与老师程序同级别的时间内，解决相同 的问题实例。</strong></p>
<p><img src="/2019/04/23/N-puzzle-Problem/4.png" alt="1556382042355"></p>
<p><img src="/2019/04/23/N-puzzle-Problem/5.png" alt="1556382108542"></p>
<p>对于以上后面几个初始状态，A*就已经无法解决。因为会生成太多新状态并消耗大量内存维护这些列表。直接爆内存。</p>
<h4 id="Algorithm：IDA"><a href="#Algorithm：IDA" class="headerlink" title="Algorithm：IDA*"></a>Algorithm：IDA*</h4><p>IDA*算法, ID(Iterative Deepening)指的是迭代加深.</p>
<p>   迭代加深搜索算法，在搜索过程中采用估值函数，以减少不必要的搜索。</p>
<p><strong>IDA*算法核心：</strong></p>
<p>​     设置每次可达的最大深度depth，若没有到达目标状态则加深最大深度。</p>
<p>​     采用估值函数，剪掉f(n)大于depth的路径</p>
<p>IDA*算法的步骤</p>
<p>a、首先对初始状态进行评估, 评估值作为最小限度, 而最大限度为自己的设置.这个评估值在这个问题中可以用此状态到正确状态的每个位置的曼哈顿距离来表示.</p>
<p>b、从最小限度到最大限度进行遍历, 此值作为当前dfs的限度值, 这个限度不断在有效范围内递增的过程就称作迭代加深</p>
<p>c、进行dfs, 调整状态, 将新状态加入到新的dfs中, 直到找到了一个解(由于迭代加深, 此解为最优解). 进行回溯, 加入路径, 算法结束.</p>
<p>IDA* is described as follows:</p>
<ul>
<li>Set <em>threshold</em> equal to the heuristic evaluation of the initial state.</li>
<li>Conduct a depth-first search, pruning a branch when the cost of the latest node exceeds <em>threshold</em>. If a solution is found during the search, return it.</li>
<li><p>If no solution is found during the current iteration, increment <em>threshold</em> by the minimum amount it was exceeded, and go back to the previous step.</p>
</li>
<li><p>设置<em>阈值</em>等于初始状态的启发式评估。</p>
</li>
<li>进行深度优先搜索，在最新节点的成本超过<em>阈值</em>时修剪分支。如果在搜索过程中找到解决方案，请将其返回。</li>
<li>如果在当前迭代期间未找到解决方案，则将<em>阈值</em>增加超过最小值，然后返回上一步骤。</li>
</ul>
<h4 id="Code：-1"><a href="#Code：-1" class="headerlink" title="Code："></a>Code：</h4><p>完整代码传送门：???</p>
<p>IDA*代码除了读取数据时调用了框架中的类，其他在一个类完成。</p>
<p>当时已经对框架有点绝望。由于我使用反向搜索使用框架会改很多类。加上不能与滑块公用一个算法,,所以写在一个类里面。</p>
<p>第二阶段我采用IDA*反向搜索，从目标状态到初始状态搜索，所以看代码要注意。速度会快很多，对于给定样例有的比老师快几十倍，分析过原因。不过后面理论又被自己否定，应该是由于样例的特殊性所以加快了速度。</p>
<p>main函数中调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Problem&gt; problems = ProblemFactory.getProblems(<span class="number">1</span>);</span><br><span class="line">		test2(problems);</span><br></pre></td></tr></table></figure>
<p>test2():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(ArrayList&lt;Problem&gt; problems)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Problem problem : problems) &#123;</span><br><span class="line"></span><br><span class="line">			Rstep=<span class="number">0</span>;</span><br><span class="line">			flg=<span class="number">0</span>;</span><br><span class="line">			result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200</span>][<span class="number">20</span>];</span><br><span class="line">			PuzzleState state = (PuzzleState) problem.getInitialState();</span><br><span class="line">			side = state.getSide();</span><br><span class="line">			tmp = state.getStatus();</span><br><span class="line">			System.out.println();</span><br><span class="line">			xx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">			yy = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; side * side; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (tmp[i] == <span class="number">0</span>) pos = i;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					xx[tmp[i]] = (i / side);</span><br><span class="line">					yy[tmp[i]] = (i % side);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!check(tmp)) System.out.println(<span class="string">"No"</span>);</span><br><span class="line">			mat = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; side * side; i++) mat[i] = i + <span class="number">1</span>;</span><br><span class="line">			mat[side * side - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">			pos = side * side - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">double</span> time1 = <span class="number">0</span>;</span><br><span class="line">			Stopwatch timer1 = <span class="keyword">new</span> Stopwatch();</span><br><span class="line"><span class="comment">//			for(int i=0;i&lt;100;i++)&#123;</span></span><br><span class="line"><span class="comment">//				layer[i]=-1;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">			<span class="comment">//System.out.println(H(mat));</span></span><br><span class="line">			<span class="keyword">for</span> (bound = H(mat); bound &lt;= <span class="number">100</span>; bound = dfs(<span class="number">0</span>, H(mat), <span class="number">4</span>))</span><br><span class="line">				<span class="keyword">if</span> (flg == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			time1 = timer1.elapsedTime();</span><br><span class="line">			Ans_show();</span><br><span class="line">			System.out.printf(<span class="string">"行走了 %s 步，执行了 %.3f 秒\n"</span>, Rstep, time1);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>check（）方法：检查是否可行解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;side*side;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==<span class="number">0</span>) &#123;</span><br><span class="line">				flag = i/side;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[j]&gt;a[i])&#123;</span><br><span class="line">					tot++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(side%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> tot%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			tot+= abs(flag-(side-<span class="number">1</span>));</span><br><span class="line">			<span class="keyword">if</span>(tot%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>H()方法：算曼哈顿距离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span>[] mat)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; side*side-<span class="number">1</span>; i++) &#123;</span><br><span class="line">		h += abs(xx[mat[i]] - (i / side)) + abs(yy[mat[i]] - (i % side));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok()方法：判断是否回到上一个状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y)&#123;</span><br><span class="line">		<span class="keyword">int</span> ff=x;</span><br><span class="line">		x=y;</span><br><span class="line">		y=ff;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>&amp;y==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//与操作  1 1 为1</span></span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">2</span>&amp;&amp;y==<span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDA*:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> h, <span class="keyword">int</span> las)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//g(n)+h(n)=f(n) 更新f(n) bound 最大限度  采用估值函数，剪掉f(n)大于depth的路径</span></span><br><span class="line">		<span class="keyword">if</span> (step + h &gt; bound) <span class="keyword">return</span> step + h; <span class="comment">//</span></span><br><span class="line"><span class="comment">//		if(layer[h]==-1)layer[h]=step;</span></span><br><span class="line"><span class="comment">//		if(step&gt;layer[h]+15)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf("enter\n");</span></span><br><span class="line"><span class="comment">//			return step+h;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">if</span> (h == <span class="number">0</span>) &#123; <span class="comment">// 到达最终状态 输出g(n)即可</span></span><br><span class="line">			<span class="comment">//		System.out.println(step);</span></span><br><span class="line">			flg = <span class="number">1</span>;</span><br><span class="line">			Rstep = step;</span><br><span class="line">			<span class="keyword">return</span> step;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> pos1 = pos;</span><br><span class="line">		<span class="keyword">int</span> ret = <span class="number">127</span>, x = pos1 / side, y = pos1 % side;</span><br><span class="line">		<span class="keyword">int</span> dx, dy, tar, ht, temp, i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">//四个方向扩展</span></span><br><span class="line">			dx = x + u[i];</span><br><span class="line">			dy = y + p[i];</span><br><span class="line">			<span class="keyword">if</span> (dx &lt; <span class="number">0</span> || dy &lt; <span class="number">0</span> || dx &gt; side - <span class="number">1</span> || dy &gt; side - <span class="number">1</span> || !ok(i, las)) <span class="keyword">continue</span>;</span><br><span class="line">			tar = (dx * side) + dy; <span class="comment">//计算出扩展出的新节点的一维坐标 2,2 2*4+2= 10</span></span><br><span class="line">			mat[pos1] = mat[tar]; <span class="comment">// 0的坐标等于扩展出来的点的坐标 a.mat[10]=11;</span></span><br><span class="line">			mat[tar] = <span class="number">0</span>;<span class="comment">//相当于swap()</span></span><br><span class="line">			pos = tar;</span><br><span class="line">			<span class="comment">//计算新的h值</span></span><br><span class="line">        <span class="comment">//阶段三主要在这修改 用不相交模式数据库 h(n) 为当前节点的各点的曼哈顿距离和。</span></span><br><span class="line">			ht = h - (Math.abs(xx[mat[pos1]] - dx) + Math.abs(yy[mat[pos1]] - dy))  + Math.abs(xx[mat[pos1]] - x) + Math.abs(yy[mat[pos1]] - y);</span><br><span class="line">			<span class="keyword">if</span> (step + ht &lt;= bound)</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; side*side; k++)</span><br><span class="line">					result[step][k] = mat[k];</span><br><span class="line">			temp = dfs(step + <span class="number">1</span>, ht, i);</span><br><span class="line">			<span class="keyword">if</span> (flg == <span class="number">1</span>)  <span class="keyword">return</span> temp;</span><br><span class="line">			<span class="keyword">if</span> (ret &gt; temp) ret = temp;</span><br><span class="line">			mat[tar] = mat[pos1];</span><br><span class="line">			mat[pos1] = <span class="number">0</span>;</span><br><span class="line">			pos = pos1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Result-1"><a href="#Result-1" class="headerlink" title="Result:"></a>Result:</h4><p>项目目录：SearchingAstar: E:\University\AI\SearchingAstar</p>
<table>
<thead>
<tr>
<th>No</th>
<th>Initial State</th>
<th>Steps</th>
<th>Time</th>
<th>Limited Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>8, 6, 7, 2, 5, 4, 3, 0, 1</td>
<td>31</td>
<td>0.000s</td>
<td>0.047s</td>
</tr>
<tr>
<td>2</td>
<td>6, 4, 7, 8, 5, 0, 3, 2, 1</td>
<td>31</td>
<td>0.003s</td>
<td>0.047s</td>
</tr>
<tr>
<td>3</td>
<td>8, 13, 0, 6, 1, 15, 9, 14, 3, 4, 5, 11, 7, 2, 10, 12</td>
<td>52</td>
<td>0.147s</td>
<td>0.304s</td>
</tr>
<tr>
<td>4</td>
<td>2,9,5,11, 8,3,4,14, 7,10,1,12,  0,15,6,13</td>
<td>51</td>
<td>2.423s</td>
<td>3.652s</td>
</tr>
<tr>
<td>5</td>
<td>4,7,0,9,12,10,11,8,14,6,15,1,2,5,3,13</td>
<td>56</td>
<td>0.554s</td>
<td>12.367s</td>
</tr>
<tr>
<td>6</td>
<td>12, 10, 3, 2, 0, 7, 14, 9, 1, 15, 5, 6, 8, 4, 13, 11</td>
<td>57</td>
<td>4.341s</td>
<td>75.458s</td>
</tr>
<tr>
<td>7</td>
<td>12, 1, 5, 6, 2, 11, 7, 9, 14, 10, 0, 4, 15, 3, 13, 8</td>
<td>50</td>
<td>0.058s</td>
<td>3.671s</td>
</tr>
<tr>
<td>8</td>
<td>4, 6, 15, 13, 12, 9, 10, 2, 8, 0, 7, 3, 14, 5, 1, 11</td>
<td>61</td>
<td>10.918s</td>
<td>299.286s</td>
</tr>
<tr>
<td>9</td>
<td>15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 1, 2, 0</td>
<td>70</td>
<td>1761.019s</td>
</tr>
</tbody>
</table>
<h3 id="Third-phase："><a href="#Third-phase：" class="headerlink" title="Third phase："></a>Third phase：</h3><h4 id="所需解决样例以及最多时间：-2"><a href="#所需解决样例以及最多时间：-2" class="headerlink" title="所需解决样例以及最多时间："></a>所需解决样例以及最多时间：</h4><p>​                <strong>4阶的，能够在1分钟之内，解出以下实例</strong></p>
<p><strong>说明：对于这个样例，曾听说过老师用IDA*大概跑了四十多分钟得出结果，不过由于样例的特殊性，我们可以使用反向搜索，这样会增快速度，我跑的时间不到30分钟，不过这个时间肯定也不是我们所能接受的，我们需要的是在一分钟内</strong></p>
<p><img src="/2019/04/23/N-puzzle-Problem/3.png" alt="1556378270793"></p>
<p>、</p>
<p>对于15码最复杂的状态，A*肯定不能解，会爆内存。</p>
<p>IDA*虽然在空间上消耗少，但是由于初始状态逆序数大，要搜很久，即大概三四十分钟才能解决。</p>
<p>解决办法：</p>
<p>a、曼哈顿距离加线性冲突——优化不了多少</p>
<p>b、添加不相交模式数据库（Disjoint Pattern Database Heuristics）与静态6-6-3分区</p>
<h4 id="Algorithm：IDA-Disjoint-Pattern-Database-Heuristics"><a href="#Algorithm：IDA-Disjoint-Pattern-Database-Heuristics" class="headerlink" title="Algorithm：IDA*+Disjoint Pattern Database Heuristics"></a>Algorithm：IDA*+Disjoint Pattern Database Heuristics</h4><p>这个算法就只能硬着头皮去读E.Korf和A.Felner的论文Disjoint Pattern Database Heuristics。</p>
<p>就刚开始看了Tsan-sheng Hsu的一个应该是用来讲课的pdf,看完之后？？？开始思考三连：我是，我去，我思？？？大概花了一下午的时间看完那篇pdf，当时是很崩溃的，伴随着这门课的无理取闹与老师的嗯。。。就已经绝望了，此时，滑块那边也没有进展，老师张口闭口严格证明就很无语老师你是真的没搞懂滑块吧，真准备弃了。当天晚上又因为一个评估函数的优劣性被同学怼了，心情很糟糕。</p>
<p>第二天醒来已经中午，开始接手了N-Puzzle和滑块两个问题，开始了找牛逼网友过程。也找到了那篇论文开始啃，（英语真的毁我一生）。</p>
<p>参考论文：</p>
<p>Additive Pattern Database Heuristics  ——E.Korf，A.Felner，S.Hanan</p>
<p>Disjoint Pattern Database Heuristics——E.Korf，A.Felner</p>
<p>以下内容来自论文（有些地方翻译会有问题）</p>
<h4 id="不断优化的启发式"><a href="#不断优化的启发式" class="headerlink" title="不断优化的启发式"></a>不断优化的启发式</h4><h5 id="1、曼哈顿距离"><a href="#1、曼哈顿距离" class="headerlink" title="1、曼哈顿距离"></a>1、曼哈顿距离</h5><p>​        例如，在滑动拼图拼图中，要将拼贴从位置x移动到位置y，x和y必须相邻，并且位置y必须为空。如果我们忽略空约束，我们得到一个简化的问题，任何瓦片都可以移动到任何相邻位置，并且多个瓦片可以占据相同的位置。在这个新问题中，瓦片彼此独立，我们可以通过沿着最短路径将每个瓦片移动到其目标位置来最佳地解决任何实例，计算所做的移动的数量。</p>
<p>​    <strong>解决这个简化问题的最佳解决方案的成本恰好是曼哈顿从初始状态到目标状态的距离。由于我们删除了对移动的约束，原始问题的任何解决方案也是简化问题的解决方案，并且针对简化问题的最优解决方案的成本是对原始问题的最优解决方案的成本的下限。</strong> </p>
<p>不足：曼哈顿距离之所以只是实际解决方案成本的下限，就是没有考虑到滑块的相互作用。</p>
<p>可改进：</p>
<p><strong>通过考虑其中一些相互作用，我们可以计算出更准确的可接受的启发函数。</strong></p>
<h5 id="2、Manhattan-Distance-Linear-Conflict"><a href="#2、Manhattan-Distance-Linear-Conflict" class="headerlink" title="2、Manhattan Distance+Linear Conflict"></a>2、Manhattan Distance+Linear Conflict</h5><p> Historically, the linear-conﬂict heuristic was the ﬁrst signiﬁcant improvementover Manhattan distance [5]. It applies to tiles in their goal row or column, but reversed relative to each other. For example, assume the top row of a given state contains the tiles (2 1) in that order, but in the goal state they appear in the order (1 2). To reverse them, one of the tiles must move out of the top row, to allow the other tile to pass by, and then move back into the top row. Since these two moves are not counted in the Manhattan distance of either tile, two moves can be added to the sum of the Manhattan distances of these two tiles without violating admissibility. </p>
<p>（从历史上看，线性冲突启发式是曼哈顿距离的第一个显着改进[5]。它适用于目标行或列中的切片，但相对于彼此反转。例如，假设给定状态的顶行按顺序包含tile（2 1），但在目标状态下它们按顺序出现（1 2）。要反转它们，其中一个切片必须移出顶行，以允许另一个切片通过，然后移回顶行。由于这两个移动不计入任一区块的曼哈顿距离，因此可以将两个移动添加到这两个区块的曼哈顿距离的总和而不违反可接受性。）</p>
<p>同样的想法也可以应用于其目标列中的切片。实际上，目标位置的图块可以同时参与行和列的冲突。由于解决行冲突所需的额外移动是垂直移动，而解决列冲突所需的额外移动是水平移动，因此两组移动都可以添加到曼哈顿距离，而不会违反允许性。与曼哈顿距离相比，线性冲突启发式减少了一个数量级的节点数量，成本几乎是速度的两倍，总体加速比超过五倍。接下来的两行用于不相交的模式数据库启发式。</p>
<h5 id="3、非可加性的模式数据库"><a href="#3、非可加性的模式数据库" class="headerlink" title="3、非可加性的模式数据库"></a>3、非可加性的模式数据库</h5><p><img src="/2019/04/23/N-puzzle-Problem/6.png" alt="1556464725925"></p>
<p>图显示了十五个拼图拼贴的子集，称为边缘拼贴。对于给定状态，使边缘拼贴到其目标位置所需的最小移动次数（包括其他拼块的所需移动）是解决整个拼图所需的移动次数的下限。</p>
<p>与其他瓦片的位置无关。</p>
<p>因此，我们可以预先计算所有这些值，将它们存储在内存中，并在搜索过程中查找它们。由于有七个边缘拼贴和一个空白，以及十六个不同的位置，边缘拼贴和空白的可能排列总数为16！/（16-8）！= 518,918,400。</p>
<p>对于每个排列，我们存储将数字图块和空白移动到其目标位置所需的移动次数，这需要不到一个字节。因此，我们可以将整个模式数据库表存储在少于495兆字节的内存中。</p>
<p>存储表后，我们使用IDA *搜索特定问题实例的最佳解决方案。在生成每个状态时，使用数字图块和空白的位置来计算图案数据库中的索引，并且使用相应的条目，即解决数字图块和空白所需的移动的数量，作为该状态的启发式值。</p>
<p>使用这种模式数据库，Culberson和Schaeffer将生成的节点数量减少了346倍，并将运行时间缩短了6倍，与曼哈顿距离相比[1]。将此与另一个模式数据库相结合，并将两个数据库值的最大值作为整体启发式值，将生成的节点减少大约一千，将运行时间减少十二。</p>
<p>局限：</p>
<p>非加性模式数据库的主要限制是它们无法解决更大的问题。例如，由于二十四个拼图包含25个不同的位置，一个覆盖n个拼贴和空白的模式数据库需要25！/（25  -  n  -  1）！条目。仅有六个图块和空白的数据库将需要超过24亿个条目。此外，来自仅六个瓦片的数据库的值将小于所有瓦片的曼哈顿距离。<strong>对于多个数据库，允许组合它们的最佳方法是获取其值的最大值，即使这些图块组是不相交的</strong>。原因是非加性模式数据库值包括解决模式切片所需的所有移动，包括其他切片的移动</p>
<p>可改进：</p>
<p><strong>我们希望能够在不违反可接受性的情况下对其值进行求和，以获得更准确的启发式，而不是采用最大的不同模式数据库值。这是不相交模式数据库的主要思想。</strong></p>
<h5 id="4、不相交的模式数据库（可加性的）"><a href="#4、不相交的模式数据库（可加性的）" class="headerlink" title="4、不相交的模式数据库（可加性的）"></a>4、不相交的模式数据库（可加性的）</h5><p>为了构建滑动拼图的不相交模式数据库，我们将拼贴划分为不相交的组，这样任何拼贴都不属于多个组。然后，<strong>我们预先计算每组中瓦片最小移动次数的表格，这些移动是将这些瓦片移动到其目标位置所需的</strong>。我们称这些表为一组，每组一个瓦片，一个不相交的模式数据库，或简称为adisjoint数据库。<strong>然后，给定搜索中的特定状态，对于每组图块，我们使用这些图块的位置来计算相应表格中的索引，检索解决该组中图块所需的移动次数，然后将每个组的值相加，以计算给定状态的整体启发式。该值至少与曼哈顿距离一样大，并且通常更大，因为它考虑了同一组中的切片之间的交互。</strong></p>
<p>上述不<strong>相交数据库和非附加数据库之间的关键区别</strong>在于，非加法数据库包括解决图案图块所需的所有移动，包括不在图案集中的图块移动。结果，给定两个这样的数据库，即使它们的区块之间没有重叠，我们也只能将这两个值中的最大值作为可接受的启发式，因为在一个数据库中计数的移动可能会移动另一个数据库中的区块，因此这些举动将被计算两次。在不相交的数据库中，我们只计算组中切片的移动。</p>
<p><strong>这两种类型的数据库之间的第二个区别是我们的不相交数据库不考虑空白位置，减小它们的大小。一个不相交的数据库包含了解决一组图块所需的最小移动量，对于所有可能的空白位置。</strong></p>
<p><strong>该搜索的状态由所讨论的图块的位置和空白的位置唯一地确定，并且仅计算感兴趣的图块的移动。由于滑动拼图拼图的操作员是可逆的，我们可以从其目标位置开始对每个拼贴执行单个搜索，并记录将拼块移动到每个其他位置需要多少移动。对所有图块执行此操作会生成一组表格，这些表格为每个图块的每个可能位置提供距其目标位置的曼哈顿距离。</strong></p>
<p><strong>对于每个图块，我们可以使用上述广度搜索来自动计算将图块从任何位置移动到其目标位置所需的最小移动次数的表格。这样的一组表格将包含从每个位置到其目标位置的每个瓦片的曼哈顿距离。然后，给定一个特定的状态，我们只需在相应的表中查找每个图块的位置并对结果值求和，从而计算曼哈顿距离的总和</strong>。</p>
<p><strong>因此我们可以将曼哈顿距离相加以获得可接受的启发式</strong></p>
<p><strong>作为一般规则，在对图块进行分区时，我们希望将目标状态中彼此靠近的图块组合在一起，因为这些图块将彼此交互最多。</strong></p>
<p><img src="/2019/04/23/N-puzzle-Problem/7.png" alt="1556466424757"></p>
<p><img src="/2019/04/23/N-puzzle-Problem/8.png" alt="1556466472252"></p>
<p>第一行给出了曼哈顿距离启发式的结果。</p>
<p>第二行是通过线性冲突增强的曼哈顿距离。</p>
<p><strong>第三行表示启发式，它是图4左侧所示的七和八数据库值的总和</strong></p>
<p><strong>第四行表示通过从第三行的启发式开始计算的启发式。然后，我们计算图4右侧所示的七和八数据库值的总和。最后，整体启发式是这两个总和中的最大值</strong>。</p>
<p>第一个数据列显示了启发函数在1000个初始状态下的平均值。第二列给出了每个问题实例生成的平均节点数，以找到第一个最优解。第三列显示算法的平均速度，以每秒节点数为单位，, on a 440 MegaHertz Sun Ultra10 workstation. 。第四列表示找到第一个最佳解决方案的平均运行时间（以秒为单位）。最后一列给出了生成的平均节点数，以找到问题实例的所有最优解。</p>
<p><strong>使用[12]中开发的分析结果，我们可以预测，单独使用曼哈顿距离解决二十四难题每个问题平均需要大约5万年！对于10,000个初始状态的随机样本，曼哈顿平均距离是76.078个移动，而对于我们的不相交数据库启发式，它是81.607个移动。</strong></p>
<p>采用其最大值来组合来自不同模式数据库的启发式算法。这是最通用的方法，因为任何两个可接受的启发式方法的最大值始终是另一个可接受的启发式方法。<strong>我们引入了不相交模式数据库，以允许将来自不同数据库的值相加，从而产生更准确的启发式值。不相交的模式数据库将子目标集划分为不相交的组，然后将解决每个组中所有子目标的成本加在一起。这要求组不相交，并且单个运算符仅影响单个组中的子目标。例如，在滑动拼图游戏中，每个操作员仅移动一个拼贴。这与获取不同值的最大值一样有效，但更准确，并且仍然可以接受。</strong></p>
<h5 id="5、裁剪"><a href="#5、裁剪" class="headerlink" title="5、裁剪"></a>5、裁剪</h5><p> used a technique, based on ﬁnite-state machines (FSMs), to prune duplicate nodes representing the same state arrived at via different paths in the graph</p>
<p><strong>使用了一种基于有限状态机（FSM）的技术来修剪表示通过图中不同路径到达的相同状态的重复节点[16]。 FSM修剪减少了IDA *在五个问题上产生的节点数量，范围从2.4到3.6。对于这项工作，我们没有使用FSM修剪，因为该技术很复杂，结果取决于所使用的特定FSM，使得其他研究人员难以重现相同的结果</strong>。</p>
<h5 id="6、动态分区模式数据库启发式-Dynamically-Partitioned-Database-Heuristics"><a href="#6、动态分区模式数据库启发式-Dynamically-Partitioned-Database-Heuristics" class="headerlink" title="6、动态分区模式数据库启发式  Dynamically-Partitioned Database Heuristics"></a>6、动态分区模式数据库启发式  Dynamically-Partitioned Database Heuristics</h5><p>​        <strong>之前（Korf＆Felner，2002）我们展示了如何将滑动拼图块静态划分为不相交的拼贴组以计算可接受的启发式，为每个状态和问题实例使用相同的分区。在这里，我们扩展该方法并显示它也适用于其他域。我们还提出了另一种加法启发式方法，我们将其称为动态分区模式数据库。在这里，我们动态地将问题划分为每个搜索状态的不相交的子问题</strong>。</p>
<p>论文：Additive Pattern Database Heuristics</p>
<p>15-puzzle ;24-puzzle  动态模式数据库会比静态模式数据库慢。</p>
<p>35-puzzle   动态模式数据库会比静态模式数据库快。</p>
<h4 id="Code：不相交模式数据库静态6-6-3分区"><a href="#Code：不相交模式数据库静态6-6-3分区" class="headerlink" title="Code：不相交模式数据库静态6-6-3分区"></a>Code：不相交模式数据库静态6-6-3分区</h4><p>完整代码传送门：？？？</p>
<p>模式数据库生成器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * File: PatternDatabaseGenerator.java</span></span><br><span class="line"><span class="comment"> * Author: Brian Borowski</span></span><br><span class="line"><span class="comment"> * Date created: June 10, 2010</span></span><br><span class="line"><span class="comment"> * Date last modified: May 13, 2011</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Examples:</span></span><br><span class="line"><span class="comment"> * When generating a complete pattern database (i.e. no dummy tiles):</span></span><br><span class="line"><span class="comment"> *  java PatternDatabaseGenerator 8 1,2,3,4,5,6,7,8,0 8-puzzle.db</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When generating a disjoint additive pattern database (i.e. dummy tiles 'x'):</span></span><br><span class="line"><span class="comment"> *  java PatternDatabaseGenerator 15 0,2,3,4,x,x,x,x,x,x,x,x,x,x,x,0     15-puzzle-663-0.db</span></span><br><span class="line"><span class="comment"> *  java PatternDatabaseGenerator 15 1,x,x,x,5,6,x,x,9,10,x,x,13,x,x,0   15-puzzle-663-1.db</span></span><br><span class="line"><span class="comment"> *  java PatternDatabaseGenerator 15 x,x,x,x,x,x,7,8,x,x,11,12,x,14,15,0 15-puzzle-663-2.db</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternDatabaseGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> KEY_NOT_FOUND = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numOfTiles, numOfTilesMinusOne, dimension;</span><br><span class="line"></span><br><span class="line">    PrimitiveHashMap tempMap;</span><br><span class="line">    List&lt;Entry&gt; stateToCostEntries_8_puzzle;</span><br><span class="line">    <span class="keyword">byte</span>[] costTable_15_puzzle;</span><br><span class="line">    <span class="keyword">long</span>[] configTable_15_puzzle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PatternDatabaseGenerator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> numOfTiles, <span class="keyword">final</span> <span class="keyword">long</span> boardConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> <span class="keyword">byte</span> dummyTile, <span class="keyword">final</span> String filename)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.numOfTiles = Node.numOfTiles = numOfTiles;</span><br><span class="line">        <span class="keyword">this</span>.numOfTilesMinusOne = numOfTiles - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.dimension = Node.dimension = (<span class="keyword">int</span>)Math.sqrt(numOfTiles);</span><br><span class="line"></span><br><span class="line">        DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (filename != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                                           <span class="keyword">new</span> FileOutputStream(filename)));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> FileNotFoundException fnfe) &#123;</span><br><span class="line">                System.err.println(<span class="string">"Error: Cannot open file '"</span> + filename + <span class="string">"' for output."</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numOfTilesMinusOne == <span class="number">15</span>) &#123;</span><br><span class="line">            generateFifteenPuzzleDB(dummyTile, boardConfig);</span><br><span class="line">            outputFifteenPuzzleData(filename, dos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            generateEightPuzzleDB(boardConfig);</span><br><span class="line">            outputEightPuzzleData(filename, dos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateFifteenPuzzleDB</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span> dummyTile,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">final</span> <span class="keyword">long</span> boardConfig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[] tilesInSubset = computeSubset(dummyTile, boardConfig);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] tilePositions = <span class="keyword">new</span> <span class="keyword">int</span>[tilesInSubset.length];</span><br><span class="line">        <span class="keyword">int</span> numTilesInSubset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tilePositions.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tilesInSubset[i]) &#123;</span><br><span class="line">                tilePositions[i] = numTilesInSubset++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        breadthFirstSearch(boardConfig, tilesInSubset);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tableLength = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, numTilesInSubset * <span class="number">4</span>);</span><br><span class="line">        costTable_15_puzzle = <span class="keyword">new</span> <span class="keyword">byte</span>[tableLength];</span><br><span class="line">        configTable_15_puzzle = <span class="keyword">new</span> <span class="keyword">long</span>[tableLength];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tableLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            costTable_15_puzzle[i] = KEY_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"Total states visited: "</span> + tempMap.size());</span><br><span class="line">        System.err.print(<span class="string">"Removing duplicates..."</span>);</span><br><span class="line">        <span class="keyword">final</span> Set&lt;Entry&gt; entries = tempMap.entrySet();</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;Entry&gt; it = entries.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">final</span> Entry entry = it.next();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> config = entry.getKey();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span> movesRequired = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = indexFor(config, <span class="keyword">true</span>, tilesInSubset, tilePositions);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span> moves = costTable_15_puzzle[index];</span><br><span class="line">            <span class="keyword">if</span> (moves == KEY_NOT_FOUND || movesRequired &lt; moves) &#123;</span><br><span class="line">                configTable_15_puzzle[index] = config;</span><br><span class="line">                costTable_15_puzzle[index] = movesRequired;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numElements = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tableLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (costTable_15_puzzle[i] != KEY_NOT_FOUND) &#123;</span><br><span class="line">                ++numElements;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"done"</span>);</span><br><span class="line">        System.err.println(<span class="string">"States in subset: "</span> + numElements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateEightPuzzleDB</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> boardConfig)</span> </span>&#123;</span><br><span class="line">        breadthFirstSearch(boardConfig, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> PrimitiveHashMap costMap_8_puzzle = <span class="keyword">new</span> PrimitiveHashMap();</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"Total states visited: "</span> + tempMap.size());</span><br><span class="line">        System.err.print(<span class="string">"Removing duplicates..."</span>);</span><br><span class="line">        <span class="keyword">final</span> Set&lt;Entry&gt; entries = tempMap.entrySet();</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;Entry&gt; it = entries.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">final</span> Entry entry = it.next();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> config = entry.getKey();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span> movesRequired = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span> moves = costMap_8_puzzle.get(config);</span><br><span class="line">            <span class="keyword">if</span> (moves == PrimitiveHashMap.KEY_NOT_FOUND || movesRequired &lt; moves) &#123;</span><br><span class="line">                costMap_8_puzzle.put(config, movesRequired);</span><br><span class="line">            &#125;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"done"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numElements = costMap_8_puzzle.size();</span><br><span class="line">        stateToCostEntries_8_puzzle = <span class="keyword">new</span> LinkedList&lt;Entry&gt;(costMap_8_puzzle.entrySet());</span><br><span class="line">        System.err.print(<span class="string">"Sorting entries..."</span>);</span><br><span class="line">        Collections.sort(stateToCostEntries_8_puzzle, <span class="keyword">new</span> Comparator&lt;Entry&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">final</span> Entry e1, <span class="keyword">final</span> Entry e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> e1.getValue() - e2.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.err.println(<span class="string">"done"</span>);</span><br><span class="line"></span><br><span class="line">        System.err.println(<span class="string">"States in subset: "</span> + numElements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outputFifteenPuzzleData</span><span class="params">(<span class="keyword">final</span> String filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">final</span> DataOutputStream dos)</span> </span>&#123;</span><br><span class="line">        System.err.print(<span class="string">"Writing file..."</span>);</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Write values to stdout. User can redirect stdout to a file, if desired.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; configTable_15_puzzle.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> config = configTable_15_puzzle[i];</span><br><span class="line">                System.out.println((i + <span class="number">1</span>) + <span class="string">","</span> + config + <span class="string">","</span> +</span><br><span class="line">                    costTable_15_puzzle[i] + <span class="string">","</span> +</span><br><span class="line">                    Utility.longToString(config, numOfTiles));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> ( ; i &lt; costTable_15_puzzle.length; ++i) &#123;</span><br><span class="line">                    dos.writeByte(costTable_15_puzzle[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ioe) &#123;</span><br><span class="line">                System.err.println(<span class="string">"Error: Cannot write entry "</span> + i + <span class="string">" to file."</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        dos.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ioe) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outputEightPuzzleData</span><span class="params">(<span class="keyword">final</span> String filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">final</span> DataOutputStream dos)</span> </span>&#123;</span><br><span class="line">        System.err.print(<span class="string">"Writing file..."</span>);</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;Entry&gt; listIter = stateToCostEntries_8_puzzle.iterator();</span><br><span class="line">        <span class="keyword">if</span> (filename == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Write values to stdout. User can redirect stdout to a file, if desired.</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (listIter.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">final</span> Entry entry = listIter.next();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> config = entry.getKey();</span><br><span class="line">                System.out.println(i + <span class="string">","</span> + config + <span class="string">","</span> + entry.getValue() +</span><br><span class="line">                    <span class="string">","</span> + Utility.longToString(config, numOfTiles));</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (listIter.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Entry entry = listIter.next();</span><br><span class="line">                    dos.writeLong(((Long)entry.getKey()).longValue());</span><br><span class="line">                    dos.writeByte(((Byte)entry.getValue()).byteValue());</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ioe) &#123;</span><br><span class="line">                System.err.println(<span class="string">"Error: Cannot write entry "</span> + i + <span class="string">" to file."</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        dos.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ioe) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.err.println(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breadthFirstSearch</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> boardConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> <span class="keyword">boolean</span>[] tilesInSubset)</span> </span>&#123;</span><br><span class="line">        BFSNode currentState = <span class="keyword">new</span> BFSNode(boardConfig);</span><br><span class="line">        currentState.cost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        tempMap = <span class="keyword">new</span> PrimitiveHashMap();</span><br><span class="line">        tempMap.put(boardConfig, (<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Queue&lt;BFSNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;BFSNode&gt;();</span><br><span class="line">        queue.add(currentState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> previous = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">char</span> fromDirection = currentState.direction;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fromDirection != <span class="string">'R'</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> BFSNode left = currentState.moveLeftNode(tilesInSubset);</span><br><span class="line">                <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span> moves = tempMap.get(left.boardConfig);</span><br><span class="line">                    <span class="keyword">if</span> (moves == PrimitiveHashMap.KEY_NOT_FOUND || left.cost &lt; moves) &#123;</span><br><span class="line">                        tempMap.put(left.boardConfig, left.cost);</span><br><span class="line">                        queue.add(left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fromDirection != <span class="string">'L'</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> BFSNode right = currentState.moveRightNode(tilesInSubset);</span><br><span class="line">                <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span> moves = tempMap.get(right.boardConfig);</span><br><span class="line">                    <span class="keyword">if</span> (moves == PrimitiveHashMap.KEY_NOT_FOUND || right.cost &lt; moves) &#123;</span><br><span class="line">                        tempMap.put(right.boardConfig, right.cost);</span><br><span class="line">                        queue.add(right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fromDirection != <span class="string">'D'</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> BFSNode up = currentState.moveUpNode(tilesInSubset);</span><br><span class="line">                <span class="keyword">if</span> (up != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span> moves = tempMap.get(up.boardConfig);</span><br><span class="line">                    <span class="keyword">if</span> (moves == PrimitiveHashMap.KEY_NOT_FOUND || up.cost &lt; moves) &#123;</span><br><span class="line">                        tempMap.put(up.boardConfig, up.cost);</span><br><span class="line">                        queue.add(up);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fromDirection != <span class="string">'U'</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> BFSNode down = currentState.moveDownNode(tilesInSubset);</span><br><span class="line">                <span class="keyword">if</span> (down != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span> moves = tempMap.get(down.boardConfig);</span><br><span class="line">                    <span class="keyword">if</span> (moves == PrimitiveHashMap.KEY_NOT_FOUND || down.cost &lt; moves) &#123;</span><br><span class="line">                        tempMap.put(down.boardConfig, down.cost);</span><br><span class="line">                        queue.add(down);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                currentState = queue.remove();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">byte</span> movesRequired = currentState.cost;</span><br><span class="line">                <span class="keyword">if</span> (movesRequired &gt; previous) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"Generating boards with up to "</span> + previous +</span><br><span class="line">                        <span class="string">" moves; map size: "</span> + tempMap.size());</span><br><span class="line">                    previous = movesRequired;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> boardConfig, <span class="keyword">final</span> <span class="keyword">boolean</span> isFifteenPuzzle,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> <span class="keyword">boolean</span>[] tilesInSubset, <span class="keyword">final</span> <span class="keyword">int</span>[] tilePositions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFifteenPuzzle) &#123;</span><br><span class="line">            <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = numOfTilesMinusOne; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> tile = (<span class="keyword">int</span>)((boardConfig &gt;&gt; (i &lt;&lt; <span class="number">2</span>)) &amp; <span class="number">0xF</span>);</span><br><span class="line">                <span class="keyword">if</span> (tilesInSubset[tile]) &#123;</span><br><span class="line">                    hashCode |= i &lt;&lt; (tilePositions[tile] &lt;&lt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hashCode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)boardConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] computeSubset(<span class="keyword">final</span> <span class="keyword">byte</span> dummyValue, <span class="keyword">final</span> <span class="keyword">long</span> boardConfig) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[] tilesInSubset = <span class="keyword">new</span> <span class="keyword">boolean</span>[numOfTiles];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pos = numOfTiles - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; --pos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">byte</span> tile = (<span class="keyword">byte</span>)((boardConfig &gt;&gt; (pos &lt;&lt; <span class="number">2</span>)) &amp; <span class="number">0xF</span>);</span><br><span class="line">            <span class="keyword">if</span> (tile != dummyValue &amp;&amp; tile != <span class="number">0</span>) &#123;</span><br><span class="line">                tilesInSubset[tile] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tilesInSubset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span> <span class="title">getArray</span><span class="params">(<span class="keyword">final</span> String arrayString, <span class="keyword">final</span> <span class="keyword">byte</span>[] tiles,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> <span class="keyword">int</span> numOfTiles)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> StringTokenizer st = <span class="keyword">new</span> StringTokenizer(arrayString, <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numOfTokens = st.countTokens();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Validate the number of tiles entered.</span></span><br><span class="line">        <span class="keyword">if</span> (numOfTokens &lt; numOfTiles) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Error: Input contains only "</span> + numOfTokens +</span><br><span class="line">                <span class="string">" of the "</span> + numOfTiles + <span class="string">" tiles."</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numOfTokens &gt; numOfTiles) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Error: Input exceeds required "</span> +</span><br><span class="line">                numOfTiles + <span class="string">" tiles."</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an array of String representations of the tile numbers.</span></span><br><span class="line">        <span class="keyword">final</span> String[] numStrings = <span class="keyword">new</span> String[numOfTokens];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (st.hasMoreTokens()) &#123;</span><br><span class="line">            numStrings[i++] = st.nextToken();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure each string is a number.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] tilePositions = <span class="keyword">new</span> <span class="keyword">int</span>[numOfTiles];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tiles.length; ++i) &#123;</span><br><span class="line">            tiles[i] = -<span class="number">1</span>;</span><br><span class="line">            tilePositions[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numStrings.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> String s = numStrings[i];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">byte</span> tile = Byte.parseByte(s);</span><br><span class="line">                tiles[i] = tile;</span><br><span class="line">                tilePositions[tile] = i;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!s.trim().toLowerCase().equals(<span class="string">"x"</span>)) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"Error: Expected integer or 'X' at index "</span> + (i + <span class="number">1</span>) +</span><br><span class="line">                        <span class="string">", received '"</span> + numStrings[i] + <span class="string">"'."</span>);</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> dummyTile = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Make sure no tile number is missing from the input.</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numOfTiles; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tilePositions[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"Error: Tile 0 is missing for input."</span>);</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dummyTile = (<span class="keyword">byte</span>)i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Replace 'X' (-1) tiles with the dummy value.</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tiles.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tiles[i] == -<span class="number">1</span>) &#123;</span><br><span class="line">                tiles[i] = dummyTile;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummyTile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">2</span> || args.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            System.err.println(</span><br><span class="line">                <span class="string">"Usage: java PatternDatabaseGenerator &lt;num of tiles&gt; &lt;tile order&gt; [filename]"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> puzzleSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            puzzleSize = Integer.parseInt(args[<span class="number">0</span>].trim());</span><br><span class="line">            <span class="keyword">if</span> ((puzzleSize != <span class="number">8</span>) &amp;&amp; (puzzleSize != <span class="number">15</span>)) &#123;</span><br><span class="line">                System.err.println(<span class="string">"Error: Puzzle size must be either 8 or 15."</span>);</span><br><span class="line">                System.exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++puzzleSize;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NumberFormatException nfe) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Error: Puzzle size must be either 8 or 15."</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String tileOrder = args[<span class="number">1</span>].trim();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] tiles = <span class="keyword">new</span> <span class="keyword">byte</span>[puzzleSize];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span> dummyTile = getArray(tileOrder, tiles, puzzleSize);</span><br><span class="line">        System.err.println(<span class="string">"Using dummy tile: "</span> + dummyTile);</span><br><span class="line">        String filename = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">3</span>) &#123;</span><br><span class="line">            filename = args[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> PatternDatabaseGenerator(</span><br><span class="line">                puzzleSize, Utility.byteArrayToLong(tiles), dummyTile, filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDA*:第三阶段由于使用不相交可加性的静态模式数据库，所以不能像第二阶段从目标状态找到初始状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> h, <span class="keyword">int</span> las)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (step + h &gt; bound) <span class="keyword">return</span> step + h; <span class="comment">// 从目标开始找 f(n)刚开始最小 如果有更大的则更新 f(n) 反方向找</span></span><br><span class="line"><span class="comment">//		if(layer[h]==-1)layer[h]=step;</span></span><br><span class="line"><span class="comment">//		if(step&gt;layer[h]+15)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.printf("enter\n");</span></span><br><span class="line"><span class="comment">//			return step+h;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">if</span> (h == <span class="number">0</span>) &#123; <span class="comment">// 到达最终状态 输出g(n)即可</span></span><br><span class="line">			<span class="comment">//		System.out.println(step);</span></span><br><span class="line">			flg = <span class="number">1</span>;</span><br><span class="line">			Rstep = step;</span><br><span class="line">			<span class="keyword">return</span> step;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> pos1 = pos;</span><br><span class="line">		<span class="keyword">int</span> ret = <span class="number">127</span>, x = pos1 / side, y = pos1 % side;</span><br><span class="line">		<span class="keyword">int</span> dx, dy, tar, ht, temp, i;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">//四个方向扩展</span></span><br><span class="line">			dx = x + u[i];</span><br><span class="line">			dy = y + p[i];</span><br><span class="line">			<span class="keyword">if</span> (dx &lt; <span class="number">0</span> || dy &lt; <span class="number">0</span> || dx &gt; side - <span class="number">1</span> || dy &gt; side - <span class="number">1</span> || !ok(i, las)) <span class="keyword">continue</span>;</span><br><span class="line">			tar = (dx * side) + dy; <span class="comment">//计算出扩展出的新节点的一维坐标 2,2 2*4+2= 10</span></span><br><span class="line">			tmp[pos1] = tmp[tar]; <span class="comment">// 0的坐标等于扩展出来的点的坐标 a.mat[10]=11;</span></span><br><span class="line">			tmp[tar] = <span class="number">0</span>;<span class="comment">//相当于swap()</span></span><br><span class="line">			pos = tar;</span><br><span class="line">			<span class="comment">//如果换一个评估函数呢</span></span><br><span class="line">			<span class="comment">//阶段三  使用不相交模式数据库得到评估函数 ht值为分为的块的h的和加起来</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">			ht = getH(tmp);</span><br><span class="line">			<span class="comment">//ht = h - (Math.abs(xx[mat[pos1]] - dx) + Math.abs(yy[mat[pos1]] - dy))  + Math.abs(xx[mat[pos1]] - x) + Math.abs(yy[mat[pos1]] - y);</span></span><br><span class="line">			<span class="keyword">if</span> (step + ht &lt;= bound) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; side * side; k++) &#123;</span><br><span class="line">					result[step][k] = tmp[k];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//System.out.println(i);</span></span><br><span class="line">				<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">					redir[step]=<span class="string">'r'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">					redir[step]=<span class="string">'l'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">					redir[step]=<span class="string">'d'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					redir[step]=<span class="string">'u'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = dfs(step + <span class="number">1</span>, ht, i);</span><br><span class="line">			<span class="keyword">if</span> (flg == <span class="number">1</span>)  <span class="keyword">return</span> temp;</span><br><span class="line">			<span class="keyword">if</span> (ret &gt; temp) ret = temp;</span><br><span class="line">			tmp[tar] = tmp[pos1];</span><br><span class="line">			tmp[pos1] = <span class="number">0</span>;</span><br><span class="line">			pos = pos1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>获取h值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] tilePositions = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] tileSubsets = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getH</span><span class="params">(<span class="keyword">int</span> [] tmp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> index0 = <span class="number">0</span>, index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> pos = <span class="number">15</span>; pos &gt;= <span class="number">0</span>; --pos) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> tile = tmp[pos];</span><br><span class="line">      <span class="keyword">if</span> (tile != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> subsetNumber = tileSubsets[tile];</span><br><span class="line">         <span class="keyword">switch</span> (subsetNumber) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               index2 |= pos &lt;&lt; (tilePositions[tile] &lt;&lt; <span class="number">2</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               index1 |= pos &lt;&lt; (tilePositions[tile] &lt;&lt; <span class="number">2</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">               index0 |= pos &lt;&lt; (tilePositions[tile] &lt;&lt; <span class="number">2</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> PuzzleConfiguration.costTable_15_puzzle_0[index0] +</span><br><span class="line">         PuzzleConfiguration.costTable_15_puzzle_1[index1] +</span><br><span class="line">         PuzzleConfiguration.costTable_15_puzzle_2[index2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Result-2"><a href="#Result-2" class="headerlink" title="Result:"></a>Result:</h4><p>项目目录：    SearchingAstar:    E:\University\AI\SearchingAstar3\SearchingAstar</p>
<table>
<thead>
<tr>
<th>No</th>
<th>Initial State</th>
<th>Steps</th>
<th>Time</th>
<th>Limited Time</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>8, 13, 0, 6, 1, 15, 9, 14, 3, 4, 5, 11, 7, 2, 10, 12</td>
<td>52</td>
<td>1.045s</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>2,9,5,11, 8,3,4,14, 7,10,1,12,  0,15,6,13</td>
<td>51</td>
<td>0.070s</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>4,7,0,9,12,10,11,8,14,6,15,1,2,5,3,13</td>
<td>56</td>
<td>0.028s</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>12, 10, 3, 2, 0, 7, 14, 9, 1, 15, 5, 6, 8, 4, 13, 11</td>
<td>57</td>
<td>0.180s</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>12, 1, 5, 6, 2, 11, 7, 9, 14, 10, 0, 4, 15, 3, 13, 8</td>
<td>50</td>
<td>0.009s</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>4, 6, 15, 13, 12, 9, 10, 2, 8, 0, 7, 3, 14, 5, 1, 11</td>
<td>61</td>
<td>0.987s</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 1, 2, 0</td>
<td>70</td>
<td>4.758s</td>
<td>60s</td>
</tr>
</tbody>
</table>
<h2 id="Reference-resources"><a href="#Reference-resources" class="headerlink" title="Reference resources"></a>Reference resources</h2><p>（1）Richard E. Korf a,∗, Ariel Felner b ，Disjoint pattern database heuristics</p>
<p>（2）Ariel Felner，Richard E. Korf，Sarit Hanan，Additive Pattern Database Heuristics</p>
<p><a href="https://blog.csdn.net/u013009575/article/details/17140915" target="_blank" rel="noopener">https://blog.csdn.net/u013009575/article/details/17140915</a></p>
<p><a href="http://www.brian-borowski.com/software/puzzle/" target="_blank" rel="noopener">http://www.brian-borowski.com/software/puzzle/</a></p>
<p><a href="http://www.ise.bgu.ac.il/engineering/upload/4273/naij.pdf" target="_blank" rel="noopener">http://www.ise.bgu.ac.il/engineering/upload/4273/naij.pdf</a></p>
<p><a href="http://www.cnblogs.com/beilin/p/5981483.html" target="_blank" rel="noopener">http://www.cnblogs.com/beilin/p/5981483.html</a></p>
<p><a href="https://www.cnblogs.com/fujudge/p/7398153.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.cnblogs.com/fujudge/p/7398153.html?utm_source=itdadao&amp;utm_medium=referral</a></p>
<p><a href="https://blog.csdn.net/shen_gan/article/details/8146027" target="_blank" rel="noopener">https://blog.csdn.net/shen_gan/article/details/8146027</a></p>
<p><a href="https://www.gamedev.net/articles/programming/artificial-intelligence/a-pathfinding-for-beginners-r2003/" target="_blank" rel="noopener">https://www.gamedev.net/articles/programming/artificial-intelligence/a-pathfinding-for-beginners-r2003/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/23/N-puzzle-Problem/" data-id="cjvoyct33000ya8tp311fjfhk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AI/">AI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/N-Puzzle/">N-Puzzle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/搜索/">搜索</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/23/滑块-Problem/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          滑块 Problem
        
      </div>
    </a>
  
  
    <a href="/2019/04/10/空间域图像增强/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">空间域图像增强</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI/">AI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Digital-Image/">Digital Image</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/N-Puzzle/">N-Puzzle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/N-Puzzle-Problem/">N-Puzzle Problem</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zobrist-Hash/">Zobrist Hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/codeforces题解/">codeforces题解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab基本语法-各种函数/">matlab基本语法&各种函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/千图成像/">千图成像</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图像增强/">图像增强</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/我需要光/">我需要光</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜索/">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数字图像处理/">数字图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/逆序对/">逆序对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链接/">链接</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AI/" style="font-size: 20px;">AI</a> <a href="/tags/Digital-Image/" style="font-size: 20px;">Digital Image</a> <a href="/tags/N-Puzzle/" style="font-size: 10px;">N-Puzzle</a> <a href="/tags/N-Puzzle-Problem/" style="font-size: 10px;">N-Puzzle Problem</a> <a href="/tags/Zobrist-Hash/" style="font-size: 10px;">Zobrist Hash</a> <a href="/tags/codeforces题解/" style="font-size: 10px;">codeforces题解</a> <a href="/tags/matlab基本语法-各种函数/" style="font-size: 10px;">matlab基本语法&各种函数</a> <a href="/tags/千图成像/" style="font-size: 10px;">千图成像</a> <a href="/tags/图像增强/" style="font-size: 10px;">图像增强</a> <a href="/tags/我需要光/" style="font-size: 10px;">我需要光</a> <a href="/tags/搜索/" style="font-size: 10px;">搜索</a> <a href="/tags/数字图像处理/" style="font-size: 10px;">数字图像处理</a> <a href="/tags/逆序对/" style="font-size: 10px;">逆序对</a> <a href="/tags/链接/" style="font-size: 10px;">链接</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/23/connect6/">connect6</a>
          </li>
        
          <li>
            <a href="/2019/04/23/滑块-Problem/">滑块 Problem</a>
          </li>
        
          <li>
            <a href="/2019/04/23/N-puzzle-Problem/">N-puzzle Problem</a>
          </li>
        
          <li>
            <a href="/2019/04/10/空间域图像增强/">空间域图像增强</a>
          </li>
        
          <li>
            <a href="/2019/04/10/codeforces/">codeforces</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Wood<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>